import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { execSync, spawn } from 'child_process';

interface SetupOptions {
    installPythonDeps: boolean;
    installFrontendDeps: boolean;
    initialCommit: boolean;
}

type ProjectContext = 'monorepo' | 'package-backend' | 'package-ui' | 'unknown';

/**
 * Execute a command and wait for it to complete
 * @param command The command to execute
 * @param args Command arguments
 * @param cwd Working directory
 * @param outputChannel Optional output channel to show command output
 * @returns Promise that resolves when command completes
 */
function executeCommand(
    command: string, 
    args: string[], 
    cwd: string,
    outputChannel?: vscode.OutputChannel
): Promise<void> {
    return new Promise((resolve, reject) => {
        const isWindows = process.platform === 'win32';
        const shell = isWindows ? 'powershell.exe' : '/bin/bash';
        
        const proc = spawn(command, args, {
            cwd,
            shell: shell,
            env: process.env
        });

        proc.stdout?.on('data', (data) => {
            if (outputChannel) {
                outputChannel.append(data.toString());
            }
        });

        proc.stderr?.on('data', (data) => {
            if (outputChannel) {
                outputChannel.append(data.toString());
            }
        });

        proc.on('error', (error) => {
            reject(error);
        });

        proc.on('close', (code) => {
            if (code === 0) {
                resolve();
            } else {
                reject(new Error(`Command exited with code ${code}`));
            }
        });
    });
}

export async function setupPythonProject() {
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    
    if (!workspaceFolder) {
        vscode.window.showErrorMessage('No workspace folder is open. Please open a project folder first.');
        return;
    }

    const projectRoot = workspaceFolder.uri.fsPath;
    const projectContext = detectProjectContext(projectRoot);
    
    if (!isGeneratedProject(projectRoot, projectContext)) {
        const response = await vscode.window.showWarningMessage(
            'This does not appear to be a project generated by Python Monorepo Generator. Continue anyway?',
            'Continue',
            'Cancel'
        );
        if (response !== 'Continue') {
            return;
        }
    }

    // Ask user what to setup
    const options = await promptSetupOptions(projectRoot, projectContext);
    if (!options) {
        return; // User cancelled
    }

    // Execute setup steps
    let setupCompleted = false;
    await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: "Setting up project...",
        cancellable: false
    }, async (progress) => {
        try {
            let step = 1;
            const totalSteps = [options.installPythonDeps, options.installFrontendDeps, options.initialCommit]
                .filter(Boolean).length;

            // Step 1: Install Python dependencies
            if (options.installPythonDeps) {
                progress.report({ 
                    message: `(${step}/${totalSteps}) Installing Python dependencies...`,
                    increment: 0 
                });
                await installPythonDependencies(projectRoot, projectContext);
                step++;
            }

            // Step 2: Install Frontend dependencies
            if (options.installFrontendDeps) {
                progress.report({ 
                    message: `(${step}/${totalSteps}) Installing frontend dependencies...`,
                    increment: (step - 1) * (100 / totalSteps)
                });
                await installFrontendDependencies(projectRoot, projectContext);
                step++;
            }

            // Step 3: Initial commit
            if (options.initialCommit) {
                progress.report({ 
                    message: `(${step}/${totalSteps}) Creating initial commit...`,
                    increment: (step - 1) * (100 / totalSteps)
                });
                await createInitialCommit(projectRoot);
            }

            progress.report({ increment: 100 });
            setupCompleted = true;

        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            vscode.window.showErrorMessage(`Setup failed: ${errorMessage}`);
        }
    });

    // After setup is complete, check if we should push to GitHub
    if (setupCompleted) {
        const hasGitHubRemote = await checkGitHubRemote(projectRoot);
        
        if (hasGitHubRemote && options.initialCommit) {
            // Ask if user wants to push to GitHub
            const pushChoice = await vscode.window.showInformationMessage(
                '‚úÖ Project setup completed! Push to GitHub now?',
                'Push to GitHub',
                'View README',
                'Later'
            );
            
            if (pushChoice === 'Push to GitHub') {
                await vscode.window.withProgress({
                    location: vscode.ProgressLocation.Notification,
                    title: "Pushing to GitHub...",
                    cancellable: false
                }, async () => {
                    await pushToGitHub(projectRoot);
                });
            } else if (pushChoice === 'View README') {
                const readmePath = path.join(projectRoot, 'README.md');
                vscode.workspace.openTextDocument(readmePath).then(doc => {
                    vscode.window.showTextDocument(doc).then(() => {}, () => {});
                }, () => {});
            }
        } else {
            vscode.window.showInformationMessage(
                '‚úÖ Project setup completed successfully!',
                'View README'
            ).then(selection => {
                if (selection === 'View README') {
                    const readmePath = path.join(projectRoot, 'README.md');
                    vscode.workspace.openTextDocument(readmePath).then(doc => {
                        vscode.window.showTextDocument(doc).then(() => {}, () => {});
                    }, () => {});
                }
            }, () => {});
        }
    }
}

function detectProjectContext(projectRoot: string): ProjectContext {
    const hasBackendMain = fs.existsSync(path.join(projectRoot, 'backend', 'main.py'));
    const hasFrontendWeb = fs.existsSync(path.join(projectRoot, 'frontend', 'web', 'package.json'));
    const hasFrontendMobile = fs.existsSync(path.join(projectRoot, 'frontend', 'mobile', 'package.json'));
    const hasRootPackageJson = fs.existsSync(path.join(projectRoot, 'package.json'));
    const hasRootPyproject = fs.existsSync(path.join(projectRoot, 'pyproject.toml'));
    const hasSrcFolder = fs.existsSync(path.join(projectRoot, 'src'));
    const hasTestsFolder = fs.existsSync(path.join(projectRoot, 'tests'));

    if (hasBackendMain || hasFrontendWeb || hasFrontendMobile) {
        return 'monorepo';
    }

    if (hasRootPackageJson && !hasBackendMain && !hasFrontendWeb && !hasFrontendMobile) {
        return 'package-ui';
    }

    if (hasRootPyproject && hasSrcFolder && hasTestsFolder && !hasBackendMain) {
        return 'package-backend';
    }

    return 'unknown';
}

function isGeneratedProject(projectRoot: string, projectContext: ProjectContext): boolean {
    if (projectContext !== 'unknown') {
        return true;
    }

    const markers = [
        path.join(projectRoot, '.vscode', 'settings.json'),
        path.join(projectRoot, 'GETTING_STARTED.md')
    ];

    return markers.some(marker => fs.existsSync(marker));
}

async function promptSetupOptions(projectRoot: string, projectContext: ProjectContext): Promise<SetupOptions | undefined> {
    const hasRequirements = fs.existsSync(path.join(projectRoot, 'requirements.txt'));
    const hasRequirementsDev = fs.existsSync(path.join(projectRoot, 'requirements-dev.txt'));
    const hasFrontendWeb = fs.existsSync(path.join(projectRoot, 'frontend', 'web', 'package.json'));
    const hasFrontendMobile = fs.existsSync(path.join(projectRoot, 'frontend', 'mobile', 'package.json'));
    const hasRootPackageJson = fs.existsSync(path.join(projectRoot, 'package.json'));
    const hasGit = fs.existsSync(path.join(projectRoot, '.git'));

    const items: vscode.QuickPickItem[] = [];
    const canInstallPythonDeps = projectContext === 'monorepo'
        ? hasRequirements || hasRequirementsDev
        : projectContext === 'package-backend'
            ? hasRequirements || hasRequirementsDev
            : false;

    const canInstallNodeDeps = projectContext === 'monorepo'
        ? hasFrontendWeb || hasFrontendMobile
        : projectContext === 'package-ui'
            ? hasRootPackageJson
            : false;
    
    if (canInstallPythonDeps) {
        items.push({
            label: '$(package) Install Python Dependencies',
            description: hasRequirements && hasRequirementsDev
                ? 'pip install -r requirements.txt and requirements-dev.txt'
                : hasRequirements
                    ? 'pip install -r requirements.txt'
                    : 'pip install -r requirements-dev.txt',
            picked: true
        });
    }

    if (canInstallNodeDeps) {
        items.push({
            label: projectContext === 'package-ui'
                ? '$(symbol-namespace) Install Node Dependencies'
                : '$(symbol-namespace) Install Frontend Dependencies',
            description: projectContext === 'package-ui'
                ? 'npm install in package root'
                : 'npm install for web and mobile apps',
            picked: true
        });
    }

    if (hasGit) {
        // Check if there are staged files (from initial git add)
        try {
            const staged = require('child_process').execSync('git diff --cached --name-only', {
                cwd: projectRoot,
                encoding: 'utf-8'
            }).trim();
            
            const hasStagedFiles = staged.length > 0;
            
            items.push({
                label: '$(git-commit) Create Initial Commit',
                description: hasStagedFiles 
                    ? 'Commit project structure and installed dependencies'
                    : 'git commit all changes',
                picked: hasStagedFiles // Auto-select if files are staged from project creation
            });
        } catch {
            items.push({
                label: '$(git-commit) Create Initial Commit',
                description: 'git commit all changes',
                picked: false
            });
        }
    }

    if (items.length === 0) {
        vscode.window.showWarningMessage('Nothing to setup in this project.');
        return undefined;
    }

    const selected = await vscode.window.showQuickPick(items, {
        title: 'Select Setup Steps',
        placeHolder: 'Choose what to configure',
        canPickMany: true,
        ignoreFocusOut: false
    });

    if (!selected || selected.length === 0) {
        return undefined;
    }

    return {
        installPythonDeps: selected.some(s => s.label.includes('Python Dependencies')),
        installFrontendDeps: selected.some(s => s.label.includes('Frontend Dependencies') || s.label.includes('Node Dependencies')),
        initialCommit: selected.some(s => s.label.includes('Initial Commit'))
    };
}

async function installPythonDependencies(projectRoot: string, projectContext: ProjectContext): Promise<void> {
    if (projectContext === 'package-ui') {
        return;
    }

    const outputChannel = vscode.window.createOutputChannel('Python Dependencies Setup');
    outputChannel.show();

    const isWindows = process.platform === 'win32';
    const venvPath = path.join(projectRoot, 'venv');
    const hasVenv = fs.existsSync(venvPath);

    const pipPath = hasVenv
        ? (isWindows ? path.join(venvPath, 'Scripts', 'pip.exe') : path.join(venvPath, 'bin', 'pip'))
        : undefined;
    const requirementsFiles = ['requirements.txt', 'requirements-dev.txt']
        .filter(file => fs.existsSync(path.join(projectRoot, file)));

    if (requirementsFiles.length === 0) {
        outputChannel.appendLine('‚ÑπÔ∏è No Python requirements files found.');
        return;
    }

    const runPipInstall = async (requirementsFile: string) => {
        if (pipPath) {
            await executeCommand(pipPath, ['install', '-r', requirementsFile], projectRoot, outputChannel);
            return;
        }

        try {
            await executeCommand('python', ['-m', 'pip', 'install', '-r', requirementsFile], projectRoot, outputChannel);
            return;
        } catch {
        }

        try {
            await executeCommand('python3', ['-m', 'pip', 'install', '-r', requirementsFile], projectRoot, outputChannel);
            return;
        } catch {
        }

        await executeCommand('py', ['-m', 'pip', 'install', '-r', requirementsFile], projectRoot, outputChannel);
    };

    outputChannel.appendLine('üì¶ Installing Python dependencies...\n');

    for (const requirementsFile of requirementsFiles) {
        try {
            outputChannel.appendLine(`\nüì¶ Installing ${requirementsFile}...\n`);
            await runPipInstall(requirementsFile);
            outputChannel.appendLine(`\n‚úÖ ${requirementsFile} installed successfully`);
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to install ${requirementsFile}: ${errorMsg}`);
        }
    }

    outputChannel.appendLine('\n‚úÖ All Python dependencies installed successfully!');
}

async function installFrontendDependencies(projectRoot: string, projectContext: ProjectContext): Promise<void> {
    if (projectContext === 'package-ui') {
        const outputChannel = vscode.window.createOutputChannel('Node Dependencies Setup');
        outputChannel.show();
        outputChannel.appendLine('üì¶ Installing package dependencies...\n');

        try {
            await executeCommand('npm', ['install'], projectRoot, outputChannel);
            outputChannel.appendLine('\n‚úÖ Package dependencies installed successfully!');
            return;
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to install package dependencies: ${errorMsg}`);
        }
    }

    const webPackagePath = path.join(projectRoot, 'frontend', 'web', 'package.json');
    const mobilePackagePath = path.join(projectRoot, 'frontend', 'mobile', 'package.json');

    // Install web dependencies
    if (fs.existsSync(webPackagePath)) {
        const outputChannel = vscode.window.createOutputChannel('Web Dependencies Setup');
        outputChannel.show();
        outputChannel.appendLine('üì¶ Installing web dependencies...\n');
        
        try {
            await executeCommand('npm', ['install'], path.join(projectRoot, 'frontend', 'web'), outputChannel);
            outputChannel.appendLine('\n‚úÖ Web dependencies installed successfully!');
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to install web dependencies: ${errorMsg}`);
        }
    }

    // Install mobile dependencies
    if (fs.existsSync(mobilePackagePath)) {
        const outputChannel = vscode.window.createOutputChannel('Mobile Dependencies Setup');
        outputChannel.show();
        outputChannel.appendLine('üì¶ Installing mobile dependencies...\n');
        
        try {
            await executeCommand('npm', ['install'], path.join(projectRoot, 'frontend', 'mobile'), outputChannel);
            outputChannel.appendLine('\n‚úÖ Mobile dependencies installed successfully!');
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            throw new Error(`Failed to install mobile dependencies: ${errorMsg}`);
        }
    }
}

async function createInitialCommit(projectRoot: string): Promise<void> {
    try {
        // Set environment to prevent Git from opening an editor
        const gitEnv = {
            ...process.env,
            GIT_EDITOR: 'true',
            GIT_TERMINAL_PROMPT: '0'
        };

        // Check if there are uncommitted changes
        const status = execSync('git status --porcelain', { 
            cwd: projectRoot, 
            encoding: 'utf-8',
            env: gitEnv
        });

        if (status.trim().length === 0) {
            vscode.window.showInformationMessage('No changes to commit.');
            return;
        }

        // Stage all files (including any new files like package-lock.json)
        execSync('git add .', { cwd: projectRoot, env: gitEnv });

        // Create initial commit with comprehensive message
        const commitMessage = 'Initial commit';
        execSync(`git commit -m "${commitMessage}" --no-edit`, { 
            cwd: projectRoot,
            encoding: 'utf-8',
            env: gitEnv
        });

        vscode.window.showInformationMessage('‚úÖ Initial commit created successfully!');

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(`Git commit failed: ${errorMessage}`);
    }
}

async function checkGitHubRemote(projectRoot: string): Promise<boolean> {
    try {
        const remotes = execSync('git remote -v', {
            cwd: projectRoot,
            encoding: 'utf-8'
        });
        
        // Check if there's an origin remote pointing to GitHub
        return remotes.includes('origin') && remotes.includes('github.com');
    } catch {
        return false;
    }
}

async function pushToGitHub(projectRoot: string): Promise<void> {
    try {
        const gitEnv = {
            ...process.env,
            GIT_EDITOR: 'true'
        };

        try {
            execSync('git rev-parse --verify HEAD', {
                cwd: projectRoot,
                env: gitEnv,
                encoding: 'utf-8',
                stdio: 'pipe'
            });
        } catch {
            const action = await vscode.window.showWarningMessage(
                'No local commits found. Create an initial commit and push now?',
                'Create Initial Commit & Push',
                'Cancel'
            );

            if (action !== 'Create Initial Commit & Push') {
                throw new Error('Push cancelled. No local commits found.');
            }

            await createInitialCommit(projectRoot);

            try {
                execSync('git rev-parse --verify HEAD', {
                    cwd: projectRoot,
                    env: gitEnv,
                    encoding: 'utf-8',
                    stdio: 'pipe'
                });
            } catch {
                throw new Error('Initial commit was not created. Add files and commit before pushing.');
            }
        }

        // Get remote URL to check repository configuration
        let remoteUrl: string;
        try {
            remoteUrl = execSync('git remote get-url origin', {
                cwd: projectRoot,
                encoding: 'utf-8'
            }).trim();
        } catch {
            throw new Error('No remote "origin" found. Please add a GitHub remote first:\ngit remote add origin <your-repo-url>');
        }

        // Verify the repository exists on GitHub before pushing
        try {
            execSync('git ls-remote origin', { 
                cwd: projectRoot, 
                env: gitEnv,
                encoding: 'utf-8',
                stdio: 'pipe'
            });
        } catch (error: any) {
            const gitError = `${error?.message || ''}\n${error?.stderr?.toString?.() || ''}`;

            if (/authentication failed|could not read username|permission denied|access denied|401|403/i.test(gitError)) {
                throw new Error('GitHub authentication failed. Sign in with Git Credential Manager (or VS Code GitHub auth) and try push again.');
            }

            if (!/repository .* not found|not found/i.test(gitError)) {
                throw new Error(`Unable to verify remote repository: ${gitError.trim()}`);
            }

            const repoName = path.basename(projectRoot);
            const choice = await vscode.window.showWarningMessage(
                `‚ö†Ô∏è The GitHub repository doesn't exist yet.\n\nYou need to create it on GitHub first.`,
                'Create on GitHub',
                'Show Instructions',
                'Cancel'
            );

            if (choice === 'Create on GitHub') {
                // Open GitHub new repository page
                await vscode.env.openExternal(vscode.Uri.parse('https://github.com/new'));
                
                // Wait for user to create the repository
                const retry = await vscode.window.showInformationMessage(
                    `üìù After creating the repository on GitHub:\n1. Use the name: ${repoName}\n2. Don't initialize with README (already exists)\n3. Click "Push Now" when ready`,
                    'Push Now',
                    'Cancel'
                );
                
                if (retry !== 'Push Now') {
                    throw new Error('Push cancelled by user');
                }

                // Verify the repository now exists
                try {
                    execSync('git ls-remote origin', { 
                        cwd: projectRoot, 
                        env: gitEnv,
                        encoding: 'utf-8',
                        stdio: 'pipe'
                    });
                } catch (verifyError: any) {
                    const verifyMessage = `${verifyError?.message || ''}\n${verifyError?.stderr?.toString?.() || ''}`;
                    throw new Error(`Repository still not reachable. Verify repo URL and authentication, then retry. Details: ${verifyMessage.trim()}`);
                }
            } else if (choice === 'Show Instructions') {
                const instructions = `To push your project to GitHub:

1. Go to https://github.com/new
2. Create a repository named: ${repoName}
3. Don't initialize with README, .gitignore, or license
4. Copy the repository URL
5. Run: git remote set-url origin <your-repo-url>
6. Try pushing again`;
                
                vscode.window.showInformationMessage(instructions, { modal: true });
                throw new Error('Push cancelled - follow the instructions shown');
            } else {
                throw new Error('Push cancelled by user');
            }
        }

        // Get current branch name
        const branch = execSync('git branch --show-current', {
            cwd: projectRoot,
            encoding: 'utf-8'
        }).trim();

        // Check if branch is master, rename to main if needed
        if (branch === 'master') {
            execSync('git branch -M main', { cwd: projectRoot, env: gitEnv });
        }

        const finalBranch = !branch || branch === 'master' ? 'main' : branch;

        // Push to GitHub
        try {
            execSync(`git push -u origin ${finalBranch}`, { 
                cwd: projectRoot, 
                env: gitEnv,
                encoding: 'utf-8'
            });
            
            vscode.window.showInformationMessage(
                `‚úÖ Successfully pushed to GitHub (${finalBranch} branch)!`,
                'Open on GitHub'
            ).then(selection => {
                if (selection === 'Open on GitHub') {
                    // Get remote URL
                    const remoteUrl = execSync('git remote get-url origin', {
                        cwd: projectRoot,
                        encoding: 'utf-8'
                    }).trim();
                    
                    // Convert git URL to https URL
                    const httpsUrl = remoteUrl
                        .replace('git@github.com:', 'https://github.com/')
                        .replace('.git', '');
                    
                    vscode.env.openExternal(vscode.Uri.parse(httpsUrl)).then(() => {}, () => {});
                }
            }, () => {});

        } catch (pushError: any) {
            // If push fails, provide helpful guidance
            if (pushError.message.includes('remote contains work')) {
                throw new Error('Remote repository is not empty. Create/select an empty GitHub repository (without README/.gitignore/license) and retry push.');
            } else if (pushError.message.includes('Repository not found')) {
                throw new Error('GitHub repository not found. Make sure you created it on GitHub first at: https://github.com/new');
            } else if (pushError.message.includes('failed to push some refs')) {
                throw new Error('Push rejected by remote (non-fast-forward). The remote likely has commits already. Use an empty repository, or run a manual sync if you want to merge histories.');
            } else {
                throw pushError;
            }
        }

    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        vscode.window.showErrorMessage(`Push to GitHub failed: ${errorMessage}`);
        throw error;
    }
}
